import { useEffect, useState } from 'react'
import { BoardProps } from '../../utils/types'
import { toast } from 'react-toastify'
import Cell from '../Cell'
import { BOARD_SIZE } from '../../utils/constants'
import Layout from '../HOCs/Layout'
import styles from './Board.module.scss'
import { BigNumber } from 'ethers'
import { convertHexadecimalToNumber } from '../../utils/functions'

function Board({ contract, gameId, yourName, startNewGame }: BoardProps) {
  const [board, setBoard] = useState(Array(BOARD_SIZE).fill(Array(BOARD_SIZE).fill(0)))
  const [isYourTurn, setIsYourTurn] = useState<boolean>(false)
  const [playerOneAddress, setPlayerOneAddress] = useState('')
  const [playerTwoAddress, setPlayerTwoAddress] = useState('')
  const [winner, setWinner] = useState(0)
  const [yourReward, setYourReward] = useState(0)
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    // Function for keeping the local game board in sync with the one on the contract
    const getGameBoard = async () => {
      // Null checks
      if (contract == null || gameId == null) return

      try {
        const gameBoard = await contract.getGameBoard(gameId)
        setBoard(gameBoard)
      } catch (err: any) {
        toast.error(err.reason)
      }
    }

    const getBothPlayers = async () => {
      // Null checks
      if (contract == null || gameId == null) return

      try {
        // Getting the game object with gameId as specified by parameters
        const game = await contract.games(gameId)

        setPlayerOneAddress(game.playerOne.toLowerCase())
        setPlayerTwoAddress(game.playerTwo.toLowerCase())

        // First turn is of Player-1
        if (yourName === 'Player-1') {
          setIsYourTurn(true)
        }
      } catch (err: any) {
        toast.error(err.reason)
      }
    }

    getBothPlayers()
    getGameBoard()
  }, [contract, gameId])

  const updateGameBoard = (rowIdx: number, colIdx: number, isOtherPlayerMove = false) => {
    const newBoard = [...board]
    const newRow = [...newBoard[rowIdx]]

    /**
     * 1 -> Player-1's move
     * 2 -> Player-2's move
     */

    if (yourName === 'Player-1') {
      // Other player is Player-2, so 2 is used for his/her move
      if (isOtherPlayerMove) newRow[colIdx] = 2
      // Your move, so 1 is used
      else newRow[colIdx] = 1
    } else {
      // Other player is Player-1, so 1 is used for his/her move
      if (isOtherPlayerMove) newRow[colIdx] = 1
      // Your move, so 2 is used
      else newRow[colIdx] = 2
    }

    newBoard[rowIdx] = newRow

    setBoard(newBoard)
  }

  // Function for getting player's address
  const getPlayerAddress = (playerName: string) => {
    if (playerName === 'Player-1') {
      return playerOneAddress
    }

    return playerTwoAddress
  }

  useEffect(() => {
    // Null checks
    if (contract == null || gameId == null) return

    const madeMoveListener = (
      eventGameId: BigNumber,
      rowIdx: BigNumber,
      colIdx: BigNumber,
      senderAddress: string
    ) => {
      /**
       * Ignoring the -
       * 1. Events that doesn't belongs to our game
       * 2. Event that is generated by our move
       */
      if (
        convertHexadecimalToNumber(eventGameId) !== gameId ||
        getPlayerAddress(yourName) === senderAddress.toLowerCase()
      )
        return

      updateGameBoard(convertHexadecimalToNumber(rowIdx), convertHexadecimalToNumber(colIdx), true)
      setIsYourTurn(true)
    }

    const haveWinnerListener = (eventGameId: BigNumber, winner: number, rewardPool: BigNumber) => {
      // Ignoring the events that doesn't belongs to our game
      if (convertHexadecimalToNumber(eventGameId) !== gameId) return

      setWinner(winner)
      setPlayerReward(winner, convertHexadecimalToNumber(rewardPool))

      // Unsubscribing from MadeMove events as game is over
      contract.off('MadeMove', madeMoveListener)
    }

    // Subscribing to MadeMove events for listening other player's moves
    contract.on('MadeMove', madeMoveListener)

    // Subscribing to HaveWinner event for stoping the game
    contract.on('HaveWinner', haveWinnerListener)

    return () => {
      // Unsubscribing to MadeMove and HaveWinner events on unmount
      contract.off('MadeMove', madeMoveListener)
      contract.off('HaveWinner', haveWinnerListener)
    }
  }, [gameId, contract, board])

  const handleCellClick = async (rowIdx: number, colIdx: number) => {
    // Ignoring in case of null values and already played positions
    if (contract == null || gameId == null || board[rowIdx][colIdx]) return

    try {
      setIsLoading(true)

      // Calling makeMove function of the contract
      const transaction = await contract.makeMove(rowIdx, colIdx, gameId)

      // Waiting for the transaction to be mined
      const receipt = await transaction.wait()

      // Checking if game is over after this move by checking for HaveWinner event
      const event = receipt.events.find((e: any) => e.event === 'HaveWinner')

      if (event) {
        const winner = event.args[1]
        setWinner(winner)
      }

      updateGameBoard(rowIdx, colIdx)
      setIsYourTurn(false)
      setIsLoading(false)
    } catch (err: any) {
      toast.error(err.reason)
      setIsLoading(false)
    }
  }

  /**
   *
   * @returns true
   * If -
   * 1. Any transaction is happening
   * 2. Its other player's turn
   * 3. Game is over
   *
   * Else
   * @returns false
   */
  const isCellDisabled = () => {
    if (isLoading || !isYourTurn || winner !== 0) return true
    return false
  }

  const setPlayerReward = (winner: number, rewardPool: number) => {
    // Is user Player-1 and Player-1 is winner
    const areYouPlayer1AndWinner = winner === 0 && yourName === 'Player-1'

    // Is user Player-2 and Player-2 is winner
    const areYouPlayer2AndWinner = winner === 1 && yourName === 'Player-2'

    // Both players get equal amount in case of a draw
    if (winner === 3) setYourReward(rewardPool / 2)
    // Winner gets all the reward
    else if (areYouPlayer1AndWinner || areYouPlayer2AndWinner) setYourReward(rewardPool)
    // Loser gets zero
    else setYourReward(0)
  }

  return (
    <Layout isLoading={isLoading}>
      <div className={styles.board}>
        {/* If game is still running */}
        {!winner && (
          <>
            {isYourTurn ? (
              <p className={styles.turn_status}>Your turn</p>
            ) : (
              <p className={styles.turn_status}>Let the other player play the move</p>
            )}
          </>
        )}

        {board.map((row, rowIdx) => {
          return (
            <div className={styles.board_row} key={rowIdx}>
              {row.map((cell: number, colIdx: number) => {
                return (
                  <Cell
                    value={cell}
                    isDisabled={isCellDisabled()}
                    onCellClick={() => handleCellClick(rowIdx, colIdx)}
                    key={colIdx}
                  />
                )
              })}
            </div>
          )
        })}

        <WinnerNotification winner={winner} />

        {/* If game is over */}
        {winner !== 0 && (
          <>
            <p className={styles.rewards}>{`Your Rewards : ${yourReward}`}</p>
            <button className={styles.new_game_btn} onClick={startNewGame}>
              Start New Game
            </button>
          </>
        )}
      </div>
    </Layout>
  )
}

export default Board

interface WinnerNotificationProps {
  winner: number
}

const WinnerNotification = ({ winner }: WinnerNotificationProps) => {
  // Player-1 wins the game
  if (winner === 1) return <p className={styles.game_status}>Player-1 wins this game.</p>

  // Player-2 wins the game
  if (winner === 2) return <p className={styles.game_status}>Player-2 wins this game. </p>

  // Game is a draw
  if (winner === 3)
    return <p className={styles.game_status}>This game is a draw between Player-1 and Player-2.</p>

  // Game is still running
  return <></>
}
